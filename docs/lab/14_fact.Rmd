---
title: '**Analisi Fattoriale**'
output:
  html_document:
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---


```{r startup, include = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = T, eval= T, message=F, warning=F, error=F, comment=NA, cache=F, R.options=list(width=220))
```

# Il modello fattoriale

Si consideri il modello fattoriale con $k=1$ fattore e $p=3$ variabili:
$$\underset{p\times 1}{x} = \underset{p\times k}{\Lambda}\underset{k\times 1}{f} + \underset{p\times 1}{u}$$

Si generino $n=20$ osservazioni indipendenti e identicamente distribuite da questo modello, salvando ciascuna osservazione $x$ nella riga $i$-sima della matrice $\underset{n\times p}{X}$. Per generare i dati, impostare il seme generatore dei numeri casuali `set.seed(123)` e specificare:

* pesi fattoriali $\Lambda = (\lambda_1,\lambda_2,\lambda_3)'=(0.5,0.2,-0.1)'$
* varianze specifiche $diag(\Psi) = (\psi_1,\psi_2,\psi_3) = (0.0225, 0.0025, 0.008)$;
* $f \sim N(0,1)$
* $u \sim N_3(\underset{3\times 1}{0},\Psi)$ 

```{r}
n <- 20
p <- 3
Lambda <- matrix(c(0.5,0.2,-0.1), ncol=1)
Psi <- diag(c(0.0225, 0.0025, 0.008))
X <- matrix(NA,nrow=n,ncol=p)
set.seed(123)
for (i in 1:n){
f <- rnorm(1)
u <- rnorm(p, mean=0, sd=sqrt(diag(Psi)) )
X[i,] <- Lambda %*% f + u 
}
```

La geometria del modello fattoriale può essere rappresentata graficamente come segue: i punti neri sono le osservazioni $x$ generate come $\Lambda f$ (punti rossi) e aggiungendo l'errore $u$ (linee grigie).
La retta rossa rappresenta il sottospazio dimensionale lungo il quale devono cadere tutti i valori di $f$ mostrato in rosso. 

```{r, echo=F}
X <- matrix(NA,nrow=n,ncol=p)
f <- vector()
u <- X
set.seed(123)
for (i in 1:n){
f[i] <- rnorm(1)
u[i,] <- rnorm(p, mean=0, sd=sqrt(diag(Psi)) )
X[i,] <- Lambda %*% f[i] + u[i,]
}
library(scatterplot3d)
s3d <- scatterplot3d(X,xlab=expression(x[1]),ylab=expression(x[2]),
zlab=expression(x[3]),pch=16)
s3d$points3d(matrix(seq(from=min(f)-1,to=max(f)+1,length.out=2),ncol=1)%*%t(Lambda), col="red",type="l")
fw = f%*%t(Lambda)
s3d$points3d(fw,col="red",pch=16)
for (i in 1:n) {
s3d$points3d(x=c(X[i,1],fw[i,1]),y=c(X[i,2],fw[i,2]),z=c(X[i,3],fw[i,3]),
col="grey",type="l") 
}
```


1. Calcolare la matrice di varianze/covarianze $\Sigma = \Lambda \Lambda' + \Psi$ e confrontarla con la sua stima $S$ ottenuta dalla matrice dei dati $X$

```{r}
Sigma = Lambda %*% t(Lambda) + Psi
round(Sigma,2)
S = var(X) * ((n-1)/n)
round(S,2)
```

2. Calcolare la matrice di correlazione $\mathbb{C}\mathrm{orr}(x)=D^{-1/2}\Sigma D^{-1/2}$, con $D = diag(\Sigma)=diag(\sigma_{11},\ldots,\sigma_{pp})$, e confrontarla con la sua stima $R$ ottenuta dalla matrice dei dati $X$;

```{r}
D = diag(diag(Sigma)^(-1/2))
Corr_x = D %*% Sigma %*% D
round(Corr_x,2)
R = cor(X) 
round(R,2)
```

3. Calcolare i pesi fattoriali $\Lambda_z = D^{-1/2} \Lambda$ e le varianze specifiche $\Psi_z = D^{-1/2} \Psi (D^{-1/2})'$ del modello fattoriale relativo alla standardizzazione
$$\underset{p\times 1}{z} = D^{-1/2} \underset{p\times 1}{y} = \Lambda_zf + u_z$$


```{r}
# pesi fattoriali z
Lambda_z = D %*% Lambda
round(Lambda_z,2)
# varianze specifiche z
Psi_z = D %*% Psi %*% t(D)
diag(Psi_z)
# modello fattoriale per dati standardizzati
Lambda_z %*% t(Lambda_z) + Psi_z
Corr_x
```

3. Stimare con il metodo della massima verosimiglianza il modello fattoriale con $k=1$ fattore (funzione `factanal()`, argomenti `factors=1` e  `rotation="none"`), ed ottenere
* la stima della matrice dei pesi fattoriali $\hat{\Lambda}_z$;
* la stima delle comunalità;
* la stima delle varianze specifiche, i.e. gli elementi diagonali di $\hat{\Psi}_z$;

```{r}
af <- factanal(x=X, factors=1, rotation="none", scores = "regression") 
af
# stima dei pesi fattoriali
hatLambda_z <- af$loadings[,]
round(hatLambda_z,3)
# veri valori
round(Lambda_z,3)
# stima delle comunalità
hatH2 <- apply(af$loadings^2,1,sum)
round(hatH2,3)
# veri valori
H2 <- apply(Lambda_z^2,1,sum)
round(H2,3)
# stima delle varianze specifiche
hatPsi_z <- diag(af$uniquenesses)
round(diag(hatPsi_z),3)
# veri valori
round(diag(Psi_z),3)
```

4. Calcolare la differenza tra $\mathbb{C}\mathrm{orr}(x)$ e $\hat{\Lambda}_z \hat{\Lambda}_z' + \hat{\Psi}_z$

```{r}
# differenza vera correlazione e stima
round(Corr_x - ( hatLambda_z%*%t(hatLambda_z) + hatPsi_z ),5)
```

5. Calcolare le stime $\hat\Lambda = D^{1/2}\hat \Lambda_z$ e $\hat\Psi = D^{1/2}\hat\Psi_z D^{1/2}$ 

```{r}
A = diag(diag(Sigma))
hatLambda = A^(1/2) %*% hatLambda_z
round(hatLambda, 4)
# vero valore
Lambda
hatPsi <- A^(1/2) %*% hatPsi_z %*% A^(1/2)
round(hatPsi, 4)
# vero valore
Psi
```

6. Calcolare i punteggi fattoriali con il metodo di Thompson
$$\hat f_i = \hat \Lambda' S^{-1}  x_i$$
e confrontarli con le vere realizzazioni di $f$ tramite un diagramma di dispersione.

```{r}
Xtilde = scale(X, center=TRUE, scale=FALSE)
hatf_thompson = apply(Xtilde,1, function(x) t(hatLambda) %*% solve(S) %*% x) 
plot(hatf_thompson, f)
abline(a=0,b=1)
```

7. Calcolare i punteggi fattoriali con il metodo di Bartlett
$$\hat f_i = (\hat \Lambda' \hat{\Psi}^{-1} \hat \Lambda) \hat \Lambda' \hat{\Psi}^{-1}  x_i$$
e confrontarli con le vere realizzazioni di $f$ tramite un diagramma di dispersione.

```{r}
hatf_bartlett = apply(Xtilde,1, function(x) solve(t(hatLambda) %*% solve(hatPsi) %*% hatLambda) %*% t(hatLambda) %*% solve(hatPsi)%*% x) 
# uguale a 
hatf = af$scores
sum(hatf_bartlett- hatf)
plot(hatf_bartlett, f)
abline(a=0,b=1, "dashed")
```



# Dati Esami

Si consideri la seguente matrice di correlazione

```{r, echo=T}
rm(list=ls())
R = matrix(c(
 1.000, 0.439, 0.410, 0.288, 0.329, 0.248,
 0.439, 1.000, 0.351, 0.354, 0.320, 0.329,
 0.410, 0.351, 1.000, 0.164, 0.190, 0.181,
 0.288, 0.354, 0.164, 1.000, 0.595, 0.470,
 0.329, 0.320, 0.190, 0.595, 1.000, 0.464,
 0.248, 0.329, 0.181, 0.470, 0.464, 1.000
), byrow=T, ncol=6)
colnames(R) = c("Gaelic", "English", "History", "Arithmetic", "Algebra", "Geometry")
R
```

relativa ai voti di $n=220$ studenti maschi nelle materie *Gaelic*, *English*, *History*, *Arithmetic*, *Algebra* e *Geometry* ($p=6$). Interpretare la matrice di correlazione. 

```{r}
library(corrplot)
corrplot(R, diag=FALSE, type = 'upper')
```


I voti tra le materie sono correlati positivamente, ovvero gli studenti che vanno bene in una specifica materia vanno bene anche nelle altre. Le correlazioni più forti si trovano nel gruppo delle materie matematiche, e in misura leggermente inferiore, nel gruppo delle
materie umanistiche, mentre c'è meno correlazione tra i due gruppi di materie.  

1. Stimare con il metodo della massima verosimiglianza il modello fattoriale con $k=2$ fattori (funzione `factanal()`, argomenti `factors=2` e  `rotation="none"`), ottenendo la stima della matrice dei pesi fattoriali, interpretando i due fattori ottenuti;


```{r}
n = 220
# modello fattoriale con 2 fattori senza rotazione
af <- factanal(covmat=R, factors=2, rotation="none", n.obs=n) 
af
# stima dei pesi fattoriali
Lambda <- af$loadings[,]
round(Lambda,3)
# primo fattore "andare bene a scuola"
# secondo fattore "math vs non-math"
```

2. Stimare il modello fattoriale con $k=2$ fattori eseguendo la rotazione `varimax` della matrice dei pesi fattoriali (argomento `rotation="varimax"`).
Confrontare le stime delle varianze specifiche e della matrice dei pesi fattoriali con la soluzione senza rotazione. 


```{r}
# rotazione varimax
af2 <- factanal(covmat = R, factors=2, rotation="varimax", n.obs=n)
af2

# matrice di rotazione
af2$rotmat

# la matrice dei pesi fattoriali cambia
af2$loadings
# primo fattore "math"
# secondo fattore "non-math"

# rappresentazione grafica della rotazione
plot(af$loadings,xlim=c(-1,1), ylim=c(-1,1), pch="", asp=1)
text(af$loadings, colnames(R))
abline(h=0)
abline(v=0)
af2 <- varimax(af$loadings,normalize=FALSE)
abline(0, af2$rotmat[2,1]/af2$rotmat[1,1], lty=2)
abline(0, af2$rotmat[2,2]/af2$rotmat[1,2], lty=2)
```

3. Si riporti il $p$-value del test rapporto di verosimiglianza per verificare l'ipotesi nulla $H_0:$ `$k=1$ fattore è sufficiente', e si concluda ad un livello di significatività del $5\%$ se è opportuno utilizzare il modello fattoriale ad 1 fattore. 

```{r, echo=T}
factanal(covmat=R, factors=1, n.obs = n)$PVAL
```

4. Si calcoli la statistica test rapporto di verosimiglianza 
$$T= n \log (|\hat{\Lambda} \hat{\Lambda}' + \hat{\Psi}|/|R|)$$ e il corrispondente $p$-value. 

```{r, echo=T}
k=1
p=6
af = factanal(covmat=R, factors=k, n.obs = n)
hatLambda = af$loadings[,]
hatPsi = diag(af$uniqueness)
fit = hatLambda %*% t(hatLambda) + hatPsi
t = n*log(det(fit)/det(R))
t
gdl = ((p-k)^2 - p - k)/2
pchisq(t, lower.tail=FALSE, df=gdl)
```


# Dati Open/Closed Book Examination Data


Caricare il dati `scor` presenti nella libreria `bootstrap` e calcolare la matrice di correlazione $\underset{p\times p}{R}$. 

```{r}
library(bootstrap)

# carico i dati:
data(scor)
X <- scor
n <- nrow(X)
p <- ncol(X)

# matrice di correlazione
R <- cor(X)
round(R, 2)
```


1. Utilizzando la funzione `factanal()`, stimare con il metodo della massima verosimiglianza il modello fattoriale con $k=2$ fattori (argomento `factors=2`) eseguendo la rotazione `varimax` della matrice dei pesi fattoriali (argomento `rotation="varimax"`).  
Stimare i punteggi fattoriali con il metodo di Thompson e rappresentarli graficamente.

```{r}
af <- factanal(X, factors=2, rotation = "varimax", scores="regression")
af$loadings
# primo fattore "open book"
# secondo fattore "closed book"
puntfat <- af$scores
# punteggi fattoriali con il metodo di thompson
plot(puntfat,pch="")
text(puntfat, labels=c(1:88))
abline(h=0)
abline(v=0)
# studente 66
X[66,]
```

# Stima del modello con il metodo dei fattori principali

Caricare il dati `scor` presenti nella libreria `bootstrap` e calcolare la matrice di correlazione $\underset{p\times p}{R}$. 

```{r}
library(bootstrap)

# carico i dati:
data(scor)
X <- scor
n <- nrow(X)
p <- ncol(X)

# matrice di correlazione
R <- cor(X)
round(R, 2)
```


1. Calcolare la stima iniziale delle comunalità $\hat{h}^2_i$ come 
$$\hat{h}^2_i = \max_{j\neq i}|r_{ij}|$$  per $i=1,\ldots,p$, dove $r_{ij}$ è l'elemento di posizione $(i,j)$ della matrice $R$. Ottenere la matrice di correlazione ridotta $$R^*= R - \hat{\Psi}$$ dove $\hat{\Psi} = diag(\hat{\psi}_1,\ldots,\hat{\psi}_p)$ con $\hat{\psi}_i = 1 - \hat{h}^2_i$.

```{r}
# sostituisco 1 sulla diagonale di R con 0
R0 <- R - diag(rep(1,p))
# calcolo la stima iniziale della comunalità
h2 <- apply(abs(R0), 2, max)
h2 
# calcolo la stima di Psi
Psi = diag(1-h2)
Psi
# calcolo la matrice di correlazione ridotta R* 
Rstar <- R - Psi 
round(Rstar,2)
```

2. Considerando il modello fattoriale con $k=2$ fattori

* calcolare la stima della matrice dei pesi fattoriali $$\hat{\Lambda} = V_k L^{1/2}_k$$ 
dopo aver ottenuto la decomposizione spettrale di $R^* = V L V'$ e dove
$\underset{p \times k}{V_k}$ contiene le prime $k$ colonne di $V$ e $\underset{k \times k}{L_k} = diag(l_1,\ldots,l_k)$. 

* aggiornare la stima delle comunalità $$\hat{h}^2_i = \sum_{j=1}^{k} \hat{\lambda}^2_{ij}$$ dove $\hat{\lambda}_{ij}$ è
l'elemento di posizione $(i,j)$ della matrice $\hat{\Lambda}$ ottenuta al passo precedente

* aggiornare la stima della matrice di correlazione ridotta $$R^*= R - \hat{\Psi}$$ dove $\hat{\Psi} = diag(\hat{\psi}_1,\ldots,\hat{\psi}_p)$ con $\hat{\psi}_i = 1 - \hat{h}^2_i$ dove $\hat{h}^2_i$ è la stima ottenuta al passo precedente

```{r}
# decomposizione spettrale di R*
eigen <- eigen(Rstar)

#  k=2
k = 2

# stima di Lambda
Lambda <- eigen$vectors[,1:k] %*% diag(eigen$values[1:k]^{1/2})
Lambda

# nuova stima comunalità 
h2.new = apply(Lambda^2, 1, sum)
h2.new

# nuova stima di Psi
Psi.new <- diag(1-h2.new)
Psi.new

# nuova stima di R*
Rstar.new = R - Psi.new
Rstar.new
```

3. Iterare per 100 volte la procedura descritta al punto 3, ottenendo le stime finali per $\hat{\Lambda}$ e $\hat{\Psi}$. Calcolare la differenza tra $R$ e  $\hat{\Lambda} \hat{\Lambda}' + \hat{\Psi}$ e commentare. 

```{r}
for (i in 1:100){
  h2 <- apply(Lambda^2, 1, sum)
  Rstar <- R0 + diag(h2)
  eigen <- eigen(Rstar)
  Lambda <- eigen$vectors[,1:k] %*% diag(eigen$values[1:k]^{1/2})
}

# stima finale per Lambda
Lambda
# stima finale per le comunalità
h2 <- apply(Lambda^2, 1, sum)
h2
# stima finale per Psi
Psi = diag(1-h2)

# differenza
fit = Lambda%*%t(Lambda) + Psi
round( R - fit, 4)
```

